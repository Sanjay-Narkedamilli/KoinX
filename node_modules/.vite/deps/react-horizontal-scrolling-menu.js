import {
  require_react
} from "./chunk-JFTBQ7A7.js";
import {
  __toESM
} from "./chunk-AC2VUBZ6.js";

// node_modules/react-horizontal-scrolling-menu/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var t = "react-horizontal-scrolling-menu";
var n = "-separator";
var o = `${t}-${n}`;
var r = `${t}--item`;
var s = `${t}--scroll-container`;
var i = `${t}--wrapper`;
var l = `${t}--inner-wrapper`;
var a = `${t}--header`;
var u = `${t}--arrow-left`;
var c = `${t}--arrow-right`;
var d = `${t}--footer`;
var h = "itemId";
var v = "data-key";
var f = "data-index";
var m = { first: "first", last: "last", onInit: "onInit", onUpdate: "onUpdate" };
var p = Object.freeze({ __proto__: null, rootClassName: t, separatorString: n, separatorClassName: o, itemClassName: r, scrollContainerClassName: s, wrapperClassName: i, innerWrapperClassName: l, headerClassName: a, arrowLeftClassName: u, arrowRightClassName: c, footerClassName: d, id: h, dataKeyAttribute: v, dataIndexAttribute: f, events: m });
function b({ className: t2 = "", children: n2, onScroll: o2 = () => {
}, scrollRef: r2 }) {
  const i2 = import_react.default.useMemo(() => `${s} ${t2}`, [t2]);
  return import_react.default.createElement("div", { className: i2, onScroll: o2, ref: r2 }, n2);
}
var g = import_react.default.memo(function({ className: t2, id: n2, index: o2, refs: r2 }) {
  const s2 = import_react.default.useRef(null);
  return r2[o2] = s2, import_react.default.createElement("div", { className: t2, [v]: n2, [f]: o2, ref: s2 });
});
var y = import_react.default.memo(function({ children: t2, className: n2, id: o2, index: r2, refs: s2 }) {
  const i2 = import_react.default.useRef(null);
  return s2[String(r2)] = i2, import_react.default.createElement("div", { className: n2, [v]: o2, [f]: r2, ref: i2 }, t2);
});
var w = (e2) => "object" == typeof e2 && null != e2 && 1 === e2.nodeType;
var E = (e2, t2) => (!t2 || "hidden" !== e2) && "visible" !== e2 && "clip" !== e2;
var I = (e2, t2) => {
  if (e2.clientHeight < e2.scrollHeight || e2.clientWidth < e2.scrollWidth) {
    const n2 = getComputedStyle(e2, null);
    return E(n2.overflowY, t2) || E(n2.overflowX, t2) || ((e3) => {
      const t3 = ((e4) => {
        if (!e4.ownerDocument || !e4.ownerDocument.defaultView)
          return null;
        try {
          return e4.ownerDocument.defaultView.frameElement;
        } catch (e5) {
          return null;
        }
      })(e3);
      return !!t3 && (t3.clientHeight < e3.scrollHeight || t3.clientWidth < e3.scrollWidth);
    })(e2);
  }
  return false;
};
var C = (e2, t2, n2, o2, r2, s2, i2, l2) => s2 < e2 && i2 > t2 || s2 > e2 && i2 < t2 ? 0 : s2 <= e2 && l2 <= n2 || i2 >= t2 && l2 >= n2 ? s2 - e2 - o2 : i2 > t2 && l2 < n2 || s2 < e2 && l2 > n2 ? i2 - t2 + r2 : 0;
var M = (e2) => {
  const t2 = e2.parentElement;
  return null == t2 ? e2.getRootNode().host || null : t2;
};
var N = (e2, t2) => {
  var n2, o2, r2, s2;
  if ("undefined" == typeof document)
    return [];
  const { scrollMode: i2, block: l2, inline: a2, boundary: u2, skipOverflowHiddenElements: c2 } = t2, d2 = "function" == typeof u2 ? u2 : (e3) => e3 !== u2;
  if (!w(e2))
    throw new TypeError("Invalid target");
  const h2 = document.scrollingElement || document.documentElement, v2 = [];
  let f2 = e2;
  for (; w(f2) && d2(f2); ) {
    if (f2 = M(f2), f2 === h2) {
      v2.push(f2);
      break;
    }
    null != f2 && f2 === document.body && I(f2) && !I(document.documentElement) || null != f2 && I(f2, c2) && v2.push(f2);
  }
  const m2 = null != (o2 = null == (n2 = window.visualViewport) ? void 0 : n2.width) ? o2 : innerWidth, p2 = null != (s2 = null == (r2 = window.visualViewport) ? void 0 : r2.height) ? s2 : innerHeight, { scrollX: b2, scrollY: g2 } = window, { height: y2, width: E2, top: N2, right: x2, bottom: k2, left: S2 } = e2.getBoundingClientRect(), { top: $2, right: R2, bottom: W2, left: B2 } = ((e3) => {
    const t3 = window.getComputedStyle(e3);
    return { top: parseFloat(t3.scrollMarginTop) || 0, right: parseFloat(t3.scrollMarginRight) || 0, bottom: parseFloat(t3.scrollMarginBottom) || 0, left: parseFloat(t3.scrollMarginLeft) || 0 };
  })(e2);
  let T2 = "start" === l2 || "nearest" === l2 ? N2 - $2 : "end" === l2 ? k2 + W2 : N2 + y2 / 2 - $2 + W2, j2 = "center" === a2 ? S2 + E2 / 2 - B2 + R2 : "end" === a2 ? x2 + R2 : S2 - B2;
  const O2 = [];
  for (let e3 = 0; e3 < v2.length; e3++) {
    const t3 = v2[e3], { height: n3, width: o3, top: r3, right: s3, bottom: u3, left: c3 } = t3.getBoundingClientRect();
    if ("if-needed" === i2 && N2 >= 0 && S2 >= 0 && k2 <= p2 && x2 <= m2 && N2 >= r3 && k2 <= u3 && S2 >= c3 && x2 <= s3)
      return O2;
    const d3 = getComputedStyle(t3), f3 = parseInt(d3.borderLeftWidth, 10), w2 = parseInt(d3.borderTopWidth, 10), I2 = parseInt(d3.borderRightWidth, 10), M2 = parseInt(d3.borderBottomWidth, 10);
    let $3 = 0, R3 = 0;
    const W3 = "offsetWidth" in t3 ? t3.offsetWidth - t3.clientWidth - f3 - I2 : 0, B3 = "offsetHeight" in t3 ? t3.offsetHeight - t3.clientHeight - w2 - M2 : 0, V2 = "offsetWidth" in t3 ? 0 === t3.offsetWidth ? 0 : o3 / t3.offsetWidth : 0, H2 = "offsetHeight" in t3 ? 0 === t3.offsetHeight ? 0 : n3 / t3.offsetHeight : 0;
    if (h2 === t3)
      $3 = "start" === l2 ? T2 : "end" === l2 ? T2 - p2 : "nearest" === l2 ? C(g2, g2 + p2, p2, w2, M2, g2 + T2, g2 + T2 + y2, y2) : T2 - p2 / 2, R3 = "start" === a2 ? j2 : "center" === a2 ? j2 - m2 / 2 : "end" === a2 ? j2 - m2 : C(b2, b2 + m2, m2, f3, I2, b2 + j2, b2 + j2 + E2, E2), $3 = Math.max(0, $3 + g2), R3 = Math.max(0, R3 + b2);
    else {
      $3 = "start" === l2 ? T2 - r3 - w2 : "end" === l2 ? T2 - u3 + M2 + B3 : "nearest" === l2 ? C(r3, u3, n3, w2, M2 + B3, T2, T2 + y2, y2) : T2 - (r3 + n3 / 2) + B3 / 2, R3 = "start" === a2 ? j2 - c3 - f3 : "center" === a2 ? j2 - (c3 + o3 / 2) + W3 / 2 : "end" === a2 ? j2 - s3 + I2 + W3 : C(c3, s3, o3, f3, I2 + W3, j2, j2 + E2, E2);
      const { scrollLeft: e4, scrollTop: i3 } = t3;
      $3 = 0 === H2 ? 0 : Math.max(0, Math.min(i3 + $3 / H2, t3.scrollHeight - n3 / H2 + B3)), R3 = 0 === V2 ? 0 : Math.max(0, Math.min(e4 + R3 / V2, t3.scrollWidth - o3 / V2 + W3)), T2 += i3 - $3, j2 += e4 - R3;
    }
    O2.push({ el: t3, top: $3, left: R3 });
  }
  return O2;
};
function x(e2, t2) {
  if (!e2.isConnected || !((e3) => {
    let t3 = e3;
    for (; t3 && t3.parentNode; ) {
      if (t3.parentNode === document)
        return true;
      t3 = t3.parentNode instanceof ShadowRoot ? t3.parentNode.host : t3.parentNode;
    }
    return false;
  })(e2))
    return;
  const n2 = ((e3) => {
    const t3 = window.getComputedStyle(e3);
    return { top: parseFloat(t3.scrollMarginTop) || 0, right: parseFloat(t3.scrollMarginRight) || 0, bottom: parseFloat(t3.scrollMarginBottom) || 0, left: parseFloat(t3.scrollMarginLeft) || 0 };
  })(e2);
  if (((e3) => "object" == typeof e3 && "function" == typeof e3.behavior)(t2))
    return t2.behavior(N(e2, t2));
  const o2 = "boolean" == typeof t2 || null == t2 ? void 0 : t2.behavior;
  for (const { el: r2, top: s2, left: i2 } of N(e2, ((e3) => false === e3 ? { block: "end", inline: "nearest" } : ((e4) => e4 === Object(e4) && 0 !== Object.keys(e4).length)(e3) ? e3 : { block: "start", inline: "nearest" })(t2))) {
    const e3 = s2 - n2.top + n2.bottom, t3 = i2 - n2.left + n2.right;
    r2.scroll({ top: e3, left: t3, behavior: o2 });
  }
}
var k;
var S = () => (k || (k = "performance" in window ? performance.now.bind(performance) : Date.now), k());
function $(e2) {
  const t2 = S(), n2 = Math.min((t2 - e2.startTime) / e2.duration, 1), o2 = e2.ease(n2), r2 = e2.startX + (e2.x - e2.startX) * o2, s2 = e2.startY + (e2.y - e2.startY) * o2;
  e2.method(r2, s2, n2, o2), r2 !== e2.x || s2 !== e2.y ? requestAnimationFrame(() => $(e2)) : e2.cb();
}
function R(e2, t2, n2) {
  let o2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 600, r2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : (e3) => 1 + --e3 * e3 * e3 * e3 * e3, s2 = arguments.length > 5 ? arguments[5] : void 0, i2 = arguments.length > 6 ? arguments[6] : void 0;
  const l2 = e2, a2 = e2.scrollLeft, u2 = e2.scrollTop;
  $({ scrollable: l2, method: (t3, n3, o3, r3) => {
    const s3 = Math.ceil(t3), l3 = Math.ceil(n3);
    e2.scrollLeft = s3, e2.scrollTop = l3, null == i2 || i2({ target: e2, elapsed: o3, value: r3, left: s3, top: l3 });
  }, startTime: S(), startX: a2, startY: u2, x: t2, y: n2, duration: o2, ease: r2, cb: s2 });
}
var W = function(e2, t2) {
  const n2 = t2 || {};
  return ((e3) => e3 && !e3.behavior || "smooth" === e3.behavior)(n2) ? x(e2, { block: n2.block, inline: n2.inline, scrollMode: n2.scrollMode, boundary: n2.boundary, skipOverflowHiddenElements: n2.skipOverflowHiddenElements, behavior: (e3) => Promise.all(e3.reduce((e4, t3) => {
    let { el: o2, left: r2, top: s2 } = t3;
    const i2 = o2.scrollLeft, l2 = o2.scrollTop;
    return i2 === r2 && l2 === s2 ? e4 : [...e4, new Promise((e5) => R(o2, r2, s2, n2.duration, n2.ease, () => e5({ el: o2, left: [i2, r2], top: [l2, s2] }), n2.onScrollChange))];
  }, [])) }) : Promise.resolve(x(e2, t2));
};
var B = (e2) => Object.values(e2).map((e3) => e3.current).filter(Boolean);
function T(e2, t2, n2, o2, r2, s2) {
  var i2;
  const l2 = (null === (i2 = null == e2 ? void 0 : e2.entry) || void 0 === i2 ? void 0 : i2.target) || e2;
  if (!l2)
    return;
  const a2 = { behavior: t2 || "smooth", inline: n2 || "end", block: o2 || "nearest" };
  return s2 ? l2.scrollIntoView(a2) : W(l2, Object.assign(Object.assign({}, r2), a2));
}
var j = (e2) => document.querySelector(`[${v}='${e2}']`);
var O = (e2) => document.querySelector(`[${f}='${e2}']`);
function V(t2) {
  return import_react.default.isValidElement(t2) && t2 || "function" == typeof t2 && import_react.default.createElement(t2, null) || !!t2 && "object" == typeof t2 && import_react.default.createElement(t2, null) || null;
}
var H = (e2) => e2.filter((e3) => !new RegExp(`.*${n}$`).test(e3));
var U = (e2) => {
  var t2;
  return String((null === (t2 = null == e2 ? void 0 : e2.props) || void 0 === t2 ? void 0 : t2[h]) || String((null == e2 ? void 0 : e2.key) || "").replace(/^\.\$/, ""));
};
function A({ children: t2, itemClassName: s2 = "", refs: i2, separatorClassName: l2 = "" }) {
  const a2 = import_react.default.Children.toArray(t2).filter(Boolean), u2 = a2.length, c2 = import_react.default.useMemo(() => `${r} ${s2}`, [s2]), d2 = import_react.default.useMemo(() => `${o} ${l2}`, [l2]);
  return import_react.default.createElement(import_react.default.Fragment, null, a2.map((t3, o2) => {
    const r2 = U(t3), s3 = "menuItem__" + r2, l3 = r2 + n, a3 = o2 + 1 === u2;
    return [import_react.default.createElement(y, { className: c2, id: r2, key: s3, refs: i2, index: o2 }, t3), !a3 && import_react.default.createElement(g, { className: d2, id: l3, refs: i2, key: l3, index: o2 + 0.1 })];
  }));
}
var L = "undefined" != typeof window ? import_react.default.useLayoutEffect : import_react.default.useEffect;
function F({ items: t2, itemsChanged: n2, refs: o2, options: r2 }) {
  const s2 = import_react.default.useRef(), i2 = import_react.default.useCallback((e2) => {
    t2.setBatch(function(e3, t3) {
      return [...e3].map((e4) => {
        var n3, o3, r3, s3;
        const i3 = e4.target, l2 = String(null !== (o3 = null === (n3 = null == i3 ? void 0 : i3.dataset) || void 0 === n3 ? void 0 : n3.key) && void 0 !== o3 ? o3 : "");
        return [l2, { index: String(null !== (s3 = null === (r3 = null == i3 ? void 0 : i3.dataset) || void 0 === r3 ? void 0 : r3.index) && void 0 !== s3 ? s3 : ""), key: l2, entry: e4, visible: e4.intersectionRatio >= t3.ratio }];
      });
    }(e2, r2));
  }, [t2, r2]);
  L(() => {
    const e2 = B(o2), t3 = s2.current || new IntersectionObserver(i2, r2);
    return s2.current = t3, e2.forEach((e3) => t3.observe(e3)), () => {
      t3.disconnect(), s2.current = void 0;
    };
  }, [i2, n2, r2, o2]);
}
var P = (t2) => import_react.default.Children.toArray(t2).map(U).filter(Boolean);
var D = class {
  constructor() {
    this.subscribe = (e2, t2) => {
      this.observers.set(e2, (this.observers.get(e2) || []).concat(t2));
    }, this.unsubscribe = (e2, t2) => {
      const n2 = (this.observers.get(e2) || []).filter((e3) => e3 !== t2);
      n2.length ? this.observers.set(e2, n2) : this.observers.delete(e2);
    }, this.emitUpdates = (e2, t2) => {
      const n2 = this.observers.get(e2) || [];
      null == n2 || n2.forEach((e3) => null == e3 ? void 0 : e3(t2));
    }, this.updateBatch = (e2, t2 = true) => {
      e2.length && (e2.forEach(([e3, t3]) => this.emitUpdates(e3, t3)), t2 && this.emitUpdates(m.onUpdate));
    }, this.update = (e2, t2) => {
      this.emitUpdates(e2, t2), this.emitUpdates(m.onUpdate);
    }, this.observers = /* @__PURE__ */ new Map();
  }
};
var _ = class extends Map {
  constructor() {
    super(), this.subscribe = (e2, t2) => this.observer.subscribe(e2, t2), this.unsubscribe = (e2, t2) => this.observer.unsubscribe(e2, t2), this.isEdgeItem = ({ key: e2, value: t2, first: n2 = this.first(), last: o2 = this.last() }) => {
      const r2 = [];
      return e2 === (null == n2 ? void 0 : n2.key) ? r2.push([m.first, t2]) : e2 === (null == o2 ? void 0 : o2.key) && r2.push([m.last, t2]), r2;
    }, this.edgeItemsCheck = (e2) => {
      const t2 = this.first(), n2 = this.last(), o2 = e2.find(([e3]) => e3 === (null == t2 ? void 0 : t2.key)), r2 = [];
      o2 && r2.push([m.first, o2[1]]);
      const s2 = e2.find(([e3]) => e3 === (null == n2 ? void 0 : n2.key));
      return s2 && r2.push([m.last, s2[1]]), r2;
    }, this.toArr = () => this.sort([...this]), this.toItems = () => this.toArr().map(([e2]) => e2), this.toItemsWithoutSeparators = () => H(this.toItems()), this.sort = (e2) => e2.sort(([, e3], [, t2]) => +e3.index - +t2.index), this.set = (e2, t2) => {
      const n2 = String(e2), o2 = [[n2, t2]];
      return super.set(n2, t2), o2.push(...this.isEdgeItem({ key: n2, value: t2, first: this.first(), last: this.last() })), this.observer.updateBatch(o2), this;
    }, this.setBatch = (e2) => {
      this.firstRun && this.observer.update(m.onInit);
      const t2 = [...e2];
      return this.sort(t2).forEach(([e3, t3]) => {
        super.set(String(e3), t3);
      }), t2.push(...this.edgeItemsCheck(t2)), this.observer.updateBatch(t2, !this.firstRun), this.firstRun = false, this;
    }, this.first = () => {
      var e2;
      return null === (e2 = this.toArr()[0]) || void 0 === e2 ? void 0 : e2[1];
    }, this.last = () => {
      var e2, t2;
      return null === (t2 = null === (e2 = this.toArr().slice(-1)) || void 0 === e2 ? void 0 : e2[0]) || void 0 === t2 ? void 0 : t2[1];
    }, this.filter = (e2) => this.toArr().filter(e2), this.find = (e2) => this.toArr().find(e2), this.findIndex = (e2) => this.toArr().findIndex(e2), this.getCurrentPos = (e2, t2) => {
      const o2 = this.toArr().filter((e3) => {
        var o3;
        return t2 ? !(null === (o3 = null == e3 ? void 0 : e3[0]) || void 0 === o3 ? void 0 : o3.includes(n)) : e3;
      }), r2 = o2.findIndex(([t3, n2]) => t3 === e2 || n2 === e2);
      return [o2, r2];
    }, this.prev = (e2, t2) => {
      var n2;
      const [o2, r2] = this.getCurrentPos(e2, !!t2);
      return -1 !== r2 ? null === (n2 = o2[r2 - 1]) || void 0 === n2 ? void 0 : n2[1] : void 0;
    }, this.next = (e2, t2) => {
      var n2;
      const [o2, r2] = this.getCurrentPos(e2, !!t2);
      return -1 !== r2 ? null === (n2 = o2[r2 + 1]) || void 0 === n2 ? void 0 : n2[1] : void 0;
    }, this.getVisible = () => this.filter((e2) => e2[1].visible), this.getVisibleElements = () => this.filter((e2) => !e2[0].includes(n) && e2[1].visible), this.observer = new D(), this.firstRun = true;
  }
};
var X = { ratio: 0.9, rootMargin: "5px", threshold: [0.05, 0.5, 0.75, 0.95] };
var Y = import_react.default.createContext({});
var q = (e2) => e2.reduce((e3, t2) => e3.concat(t2).concat(`${t2}${n}`), []).slice(0, -1);
function z(e2, t2) {
  const n2 = H(e2), o2 = H(t2);
  return { prev: () => q(function(e3, t3) {
    const n3 = e3.findIndex((e4) => e4 === (null == t3 ? void 0 : t3[0])), o3 = t3.length, r2 = n3 - o3, s2 = r2 < 0, i2 = s2 ? 0 : r2, l2 = e3.slice(i2, s2 ? o3 : n3);
    return l2.length === o3 ? l2 : e3.slice(n3, o3);
  }(n2, o2)), next: () => q(function(e3, t3) {
    const n3 = e3.findIndex((e4) => {
      var n4;
      return e4 === (null === (n4 = t3.slice(-1)) || void 0 === n4 ? void 0 : n4[0]);
    }), o3 = t3.length, r2 = n3 + o3 + 1, s2 = r2 > e3.length - 1, i2 = s2 ? e3.length - 1 : r2, l2 = e3.slice(s2 ? i2 - o3 + 1 : n3 + 1, i2);
    return l2.length === o3 ? l2 : e3.slice(e3.length - o3, e3.length + o3);
  }(n2, o2)) };
}
var K = (e2) => {
  var t2;
  const o2 = ((e3) => e3.filter((e4, t3, o3) => {
    const r3 = 0 === t3, s2 = t3 === o3.length - 1, i2 = new RegExp(n).test(e4);
    return !((r3 || s2) && i2);
  }))(e2), r2 = o2[Math.floor(o2.length / 2)];
  return { first: null == o2 ? void 0 : o2[0], center: r2, last: null === (t2 = o2.slice(-1)) || void 0 === t2 ? void 0 : t2[0] };
};
var G = { current: {} };
var J = () => {
};
function Q({ LeftArrow: t2, RightArrow: o2, children: r2, Header: s2, Footer: h2, transitionDuration: v2 = 500, transitionBehavior: f2, onInit: p2 = J, onUpdate: g2 = J, onMouseDown: y2, onMouseUp: w2, onMouseMove: E2, onScroll: I2 = J, onTouchMove: C2, onTouchStart: M2, onTouchEnd: N2, onWheel: x2 = J, options: k2 = X, scrollContainerClassName: S2 = "", itemClassName: $2 = "", separatorClassName: R2 = "", wrapperClassName: W2 = "", apiRef: B2 = G, RTL: H2, noPolyfill: U2 }) {
  const L2 = V(t2), D2 = V(o2), q2 = V(s2), z2 = V(h2), K2 = import_react.default.useRef(null), [Q2] = import_react.default.useState({}), Z = import_react.default.useMemo(() => Object.assign(Object.assign(Object.assign({}, X), k2), { root: K2.current }), [k2]), ee = import_react.default.useRef(new _()).current, te = function(t3, o3) {
    const [r3, s3] = import_react.default.useState(""), i2 = import_react.default.useMemo(() => P(t3), [t3]);
    return import_react.default.useEffect(() => {
      const e2 = i2.filter(Boolean).join("");
      o3.toItemsWithoutSeparators().filter((e3) => !i2.includes(e3)).forEach((e3) => {
        var t4, r4;
        const s4 = (null === (t4 = o3.last()) || void 0 === t4 ? void 0 : t4.key) === e3 && (null === (r4 = o3.prev(e3)) || void 0 === r4 ? void 0 : r4.key) || "";
        o3.delete(s4), o3.delete(`${e3}${n}`), o3.delete(e3);
      }), s3(e2);
    }, [i2, o3]), r3;
  }(r2, ee);
  F(import_react.default.useMemo(() => ({ items: ee, itemsChanged: te, options: Z, refs: Q2 }), [ee, te, Q2, Z]));
  const ne = import_react.default.useMemo(() => function(t3, n2, o3) {
    var r3, s3, i2;
    const l2 = !!(null === (r3 = t3.first()) || void 0 === r3 ? void 0 : r3.visible), a2 = !!(null === (s3 = t3.last()) || void 0 === s3 ? void 0 : s3.visible), u2 = (e2) => {
      var n3;
      return null === (n3 = t3.find((t4) => t4[1].key === String(e2))) || void 0 === n3 ? void 0 : n3[1];
    }, c2 = () => {
      var e2, n3;
      const o4 = null === (n3 = null === (e2 = t3.getVisible()) || void 0 === e2 ? void 0 : e2[0]) || void 0 === n3 ? void 0 : n3[1];
      return o4 ? t3.prev(o4) : void 0;
    }, d2 = () => {
      var e2;
      const n3 = null === (e2 = t3.getVisible().findLast(() => true)) || void 0 === e2 ? void 0 : e2[1];
      return n3 ? t3.next(n3) : void 0;
    }, h3 = null === (i2 = null == n2 ? void 0 : n2.boundary) || void 0 === i2 ? void 0 : i2.current;
    return { getItemById: u2, getItemElementById: j, getItemByIndex: (e2) => {
      var n3;
      return null === (n3 = t3.find((t4) => String(t4[1].index) === String(e2))) || void 0 === n3 ? void 0 : n3[1];
    }, getItemElementByIndex: O, getNextItem: d2, getNextElement: () => {
      var e2;
      const n3 = null === (e2 = t3.getVisibleElements().findLast(() => true)) || void 0 === e2 ? void 0 : e2[1];
      return n3 ? t3.next(n3, true) : void 0;
    }, getPrevItem: c2, getPrevElement: () => {
      var e2, n3;
      const o4 = null === (n3 = null === (e2 = t3.getVisibleElements()) || void 0 === e2 ? void 0 : e2[0]) || void 0 === n3 ? void 0 : n3[1];
      return o4 ? t3.prev(o4, true) : void 0;
    }, isFirstItemVisible: l2, isItemVisible: (e2) => t3.getVisibleElements().map((e3) => e3[0]).includes(String(e2)), isLastItem: (e2) => t3.last() === u2(e2), isLastItemVisible: a2, scrollNext: (e2, t4, r4, { duration: s4, boundary: i3 = h3 } = {}) => {
      const l3 = null != e2 ? e2 : null == n2 ? void 0 : n2.behavior;
      return T(d2(), l3, t4 || "start", r4 || "nearest", { boundary: i3, duration: null != s4 ? s4 : null == n2 ? void 0 : n2.duration }, o3);
    }, scrollPrev: (e2, t4, r4, { duration: s4, boundary: i3 = h3 } = {}) => {
      const l3 = null != e2 ? e2 : null == n2 ? void 0 : n2.behavior;
      return T(c2(), l3, t4 || "end", r4 || "nearest", { boundary: i3, duration: null != s4 ? s4 : null == n2 ? void 0 : n2.duration }, o3);
    }, useIsVisible: (n3, o4 = false) => {
      const [r4, s4] = import_react.default.useState(o4);
      return import_react.default.useEffect(() => {
        const e2 = (e3) => {
          s4(!!(null == e3 ? void 0 : e3.visible));
        };
        return t3.subscribe(n3, e2), () => {
          t3.unsubscribe(n3, e2);
        };
      }, [n3]), r4;
    }, scrollToItem: (e2, t4, r4, s4, i3) => {
      var l3;
      return T(e2, null != t4 ? t4 : null == n2 ? void 0 : n2.behavior, r4, s4, Object.assign(Object.assign({ boundary: h3 }, i3), { duration: null !== (l3 = null == i3 ? void 0 : i3.duration) && void 0 !== l3 ? l3 : null == n2 ? void 0 : n2.duration }), o3);
    } };
  }(ee, { duration: v2, behavior: f2, boundary: K2 }, U2), [ee, v2, f2, U2]), oe = import_react.default.useCallback(() => Object.assign(Object.assign({}, ne), { items: ee, scrollContainer: K2 }), [ne, ee, K2]), [re, se] = import_react.default.useState(() => oe());
  (({ context: t3, onInit: n2, onUpdate: o3 }) => {
    import_react.default.useEffect(() => {
      const e2 = () => n2(t3), r3 = () => o3(t3);
      return t3.items.subscribe(m.onInit, e2), t3.items.subscribe(m.onUpdate, r3), () => {
        t3.items.unsubscribe(m.onInit, e2), t3.items.unsubscribe(m.onUpdate, r3);
      };
    }, [t3, n2, o3]);
  })({ context: re, onInit: p2, onUpdate: g2 }), import_react.default.useEffect(() => se(oe()), [oe]), B2.current = re;
  const ie = import_react.default.useCallback((e2) => I2(re, e2), [I2, re]), le = import_react.default.useCallback((e2) => x2(re, e2), [x2, re]), ae = import_react.default.useMemo(() => `${i} ${W2}`, [W2]), ue = import_react.default.useMemo(() => `${S2}${H2 ? " rtl" : ""}`, [H2, S2]);
  return import_react.default.createElement("div", { className: ae, onWheel: le, onMouseDown: null == y2 ? void 0 : y2(re), onMouseUp: null == w2 ? void 0 : w2(re), onMouseMove: null == E2 ? void 0 : E2(re), onTouchStart: null == M2 ? void 0 : M2(re), onTouchMove: null == C2 ? void 0 : C2(re), onTouchEnd: null == N2 ? void 0 : N2(re) }, import_react.default.createElement(Y.Provider, { value: re }, import_react.default.createElement("div", { className: a }, q2), import_react.default.createElement("div", { className: l }, import_react.default.createElement("div", { className: u }, L2), import_react.default.createElement(b, { className: ue, onScroll: ie, scrollRef: K2 }, import_react.default.createElement(A, { refs: Q2, itemClassName: $2, separatorClassName: R2 }, r2)), import_react.default.createElement("div", { className: c }, D2)), import_react.default.createElement("div", { className: d }, z2)));
}
export {
  Q as ScrollMenu,
  Y as VisibilityContext,
  p as constants,
  K as getItemsPos,
  z as slidingWindow
};
//# sourceMappingURL=react-horizontal-scrolling-menu.js.map
